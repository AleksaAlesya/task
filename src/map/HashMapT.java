package map;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class HashMapT {

     public static void main(String[] args) {
          // конструкторы
          HashMap <Integer,String>map = new HashMap<>();
          map.put(124,"Olga");
          map.put(125,"Piter");
          map.put(128,"Olga");
          map.put(124,"Nelly");
          map.put(null,"Ilya");
          System.out.println(map);
          map.putIfAbsent(128,"Olga"); // добавь, если нет в коллекции - не добавит
          map.putIfAbsent(200,"Olga"); // добавь, если нет в коллекции - добавит
          System.out.println(map);

          map.get(124);
          map.remove(124);
          map.containsValue("Olga"); // содержит ли значение boolean
          map.containsKey("128"); // содержит ли ключ boolean
          map.keySet(); // все ключи множество
          map.values(); // все значения множество
//          map.entrySet(); // получить пары
          Iterator<Map.Entry<Integer, String>> itr = map.entrySet().iterator();
          while (itr.hasNext()) {
               System.out.println(itr.next());
          }
     }



}
/*    HashMap - это структура данных на основе массива (table), который в себе содержит пары ключ-значени

backets - элеметы массива, в котором односвязный список, содержащий в себе  node (хэшкод,ключ,значение, ссылка на след элемент)
-не отсортированная коллекция пар ключ-значение, не хранит порядок добавления
     -ключи д.б. уникальными, м.б null, если ключ повторяется, то значение перезаписывается
     -значения м. повторяться, м.б. null

     Рекомендуется, что бы Ключ был immutable, т.к. если будет изменяемым, то в последствии значения могут измениться и мы в хэшмапе не найдем по ключу


     ДОБАВЛЕНИЕ в HashMap:
    1. Сначала ключ проверяется на null, если тру - то помещается на 0 индекс массива, если там уже есть значение, то просто перезаписывается, если нет, то
      2. Находит хэшкод ключа,
      3. По хэшфункции на основе хэшкода вычисляется индекс ячейки-бакета, в который поместить пару
      2. Если пуста - записываем, если нет, то
      3. Идем по списку и сравниваем  хэшкод, есть ли такой хэш- ключа в списке, если нет - записываем в конец списка, если есть, то
      4. Проверяем ключ по equals, если есть, то перезаписываем старое значение на новое к этому ключу
      5. Если нет, идем далее по списку сравнивая и если не находим добавляет в конец списка

      При удалении элементы из мэп, размер не уменьшается и нет метода, который бы это сделал


      initial capacity =16
      loadeFactor = 0.75 - коэф. заполнения массива, при котором мэпа увеличивается в 2 р

       */

